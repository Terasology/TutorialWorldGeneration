# Facet Production

And now for some fun with metadata.  As mentioned before, we need to provide surface height information so that our rasterizer can read this data and put blocks & players in the right place.  Fortunately, the engine provides us with a facet definition for this, `ElevationFacet` - an approximate 2d representation of the surface of the world.  Each (X; Y) position holds the value of the height of the surface.

Let's start with a skeleton class:

```java
@Produces(ElevationFacet.class)
public class SurfaceProvider implements FacetProvider {
    @Override
    public void setSeed(long seed) {
    }

    @Override
    public void process(GeneratingRegion region) {
    }
}
```

The key part of this skeleton is the annotation - without it, the world builder will not know how to organize facet providers together.

Now let's reimplement our existing rasterizer data - but lets make it a little more interesting and define our surface as being located y=10, because danger happens at y=10! :P

```java
@Override
public void process(GeneratingRegion region) {
    // Create our elevation facet (we will get into borders later)
    Border3D border = region.getBorderForFacet(ElevationFacet.class);
    ElevationFacet facet = new ElevationFacet(region.getRegion(), border);

    // Loop through every position in our 2d array
    Rect2i processRegion = facet.getWorldRegion();
    for (BaseVector2i position: processRegion.contents()) {
        facet.setWorld(position, 10f);
    }

    // Pass our newly created and populated facet to the region
    region.setRegionFacet(ElevationFacet.class, facet);
}
```

Some key points to note is that `facet.getWorldRegion()` refers to world coordinates which happen to coincide with `facet.setWorld()`.  There are also methods that deal with the local coordinate system, but it is easier to stick with world positions.

We then add this to our world builder:

```java
@In
private WorldGeneratorPluginLibrary worldGeneratorPluginLibrary;

@Override
protected WorldBuilder createWorld() {
    return new WorldBuilder(worldGeneratorPluginLibrary)
           .addProvider(new SurfaceProvider())
           .addProvider(new SeaLevelProvider(0))
           .addRasterizer(new TutorialWorldRasterizer());
}
```

(Oh, right - don't forget to put in the ```SeaLevelProvider``` so that the game doesn't spawn the player 100 meters underwater! You'll need to add CoreWorlds as a dependency in the new module's `module.txt` file. Make sure to recompile or do a `gradlew idea` followed by an Intellij restart.)

Now, when we run the rasterizer, we can access this facet data that we have provided.  Lets use it:

```java
@Override
public void generateChunk(CoreChunk chunk, Region chunkRegion) {
    ElevationFacet elevationFacet = chunkRegion.getFacet(ElevationFacet.class);
    for (Vector3i position : chunkRegion.getRegion()) {
        float surfaceHeight = elevationFacet.getWorld(position.x, position.z);
        if (position.y < surfaceHeight) {
            chunk.setBlock(ChunkMath.calcBlockPos(position), dirt);
        }
    }
}
```

Be sure to get your x and z correct.  The surface height facet uses 2D (x; y) coordinates, while `Vector3i` uses y as height.

Now run the generator again and witness lots of exciting dirt at y=10!

<fig src="_media/img/facet-production.png" alt="Facet Production">A world generated by this simple world generator.</fig>
