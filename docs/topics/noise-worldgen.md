# World Generation

This page explains usages of different types of noise, basic mechanics and implementation. You can read detailed implementation in [Noise Implementation](Noise-Implementation) page. 

This page also features some example terrains, covered in this tutorial (Rolling hills and Mountains) - [Noise Sampling](./../03_Noise-Sampling.md) and [Facet Modification](../04_Facet-Modification.md). 

### Simple Terrain - `SimplexNoise`

<fig src="/_media/img/worldgen-simplex.png" alt="Simplex noise">Example of terrain generated with Simplex noise.</fig>

The above is a terrain (rolling hills) generated using `SimplexNoise`. Code sample:
```java
@Override
public void setSeed(long seed) {
    terrainNoise = new SubSampledNoise(new SimplexNoise(seed), new Vector2f(0.01f, 0.01f), 1);
}
```
The noise generates random numbers between -1 and 1. We get this result by scaling up (multiplying) the random numbers and use them  to build up world. We also use `SubsampledNoise` to smooth out the noise by "zooming in" or "stretching" the values out.

### Complex Terrain (Noise Overlaying) - `BrownianNoise`

<fig src="/_media/img/worldgen-brownian.png" alt="Simplex noise">Example of terrain generated with layered Brownian noise.</fig>
This is a terrain (mountains) generated by overlaying the first terrain which uses `SimplexNoise` with another terrain which uses `BrownianNoise(PerlinNoise)`.

```java
@Override
public void setSeed(long seed) {
    terrainNoise = new SubSampledNoise(new BrownianNoise(new PerlinNoise(seed + 2), 8), new Vector2f(0.001f, 0.001f), 1);
}
```

We overlay this noise map `BrownianNoise(PerlinNoise)` and `simplexNoise` map - from the first one - in order to get a more interesting terrain.
The mountains here are calculated by combining multiple octaves of Perlin noise at different frequencies. The octave here is `8`.
We use `seed + 2` because we want a different noise map. And same as the first terrain, we multiply the random numbers to get high mountains.

### White Noise

In this tutorial, White Noise is used to place houses. 
This noise is used for placing discrete things randomly in the world. For instance, houses, trees, floras and things that you want to evenly cover the area in.

```java
@Override
public void setSeed(long seed) {
    treesNoise = new WhiteNoise(seed);
}
```
Below is the example terrain with trees placed using White Noise. The tree generator is also in this tutorial repo.

<fig src="/_media/img/worldgen-whitenoise.png" alt="White noise">Example of trees placed based on white noise.</fig>

The trees are naturally scattered. To achieve this, we place the tree's trunk (center) at the point where random number generated by White Noise is more than 0.99. You can increase the density of trees by using a value less than 0.99. Because white noise is in the range [-1,+1], this test passes with a probability of 1/200.

```java
@Override
public void process(GeneratingRegion region) {
    Border3D border = region.getBorderForFacet(TreesFacet.class).extendBy(0, 7, 1);
    TreesFacet facet = new TreesFacet(region.getRegion(), border);

    SurfacesFacet surfacesFacet = region.getRegionFacet(SurfacesFacet.class);
    Region3i worldRegion = surfacesFacet.getWorldRegion();

    for (int wz = worldRegion.minZ(); wz <= worldRegion.maxZ(); wz++) {
        for (int wx = worldRegion.minX(); wx <= worldRegion.maxX(); wx++) {
            for (int surfaceHeight : surfacesFacet.getWorldColumn(wx, wz)) {

                // check if point is within this region
                if (facet.getWorldRegion().encompasses(wx, surfaceHeight, wz)) {
                
                    if (treesNoise.noise(wx, surfaceHeight, wz) > 0.99) {
                        facet.setWorld(wx, surfaceHeight, wz, new Tree());
                    }
                }
            }
        }
    }

    region.setRegionFacet(TreesFacet.class, facet);
}
```
We compare the noise at that point to our threshold, 0.99 and only place a tree if it's higher. This is also the logic used for houses in this tutorial.

As you can see, we don't need `SubSampledNoise` because  we don't have to smooth out the noise values. We only compare the values and then place some trees.

This terrain works almost the same as houses, covered in this tutorial. This is only to show how White Noise can help to achieve natural vegetation.

**Up till now you can see, there are a lot of parameters in `BrownianNoise` and `SubSampledNoise`. Those parameters are crucial to build up your world and to get desirable results. You may want to learn more about `BrownianNoise`, `SubsampledNoise` parameters, including octave and zooming noise map. Please head to the [Noise Implementation](./noise-implementation.md) page.**

## Summary - Which noise to use?

`PerlinNoise`, `SimplexNoise`: use to create simple, organic terrain. **It's best to use Simplex Noise as it is faster.**

`WhiteNoise`: use for placing discrete things randomly in the world. For instance, houses, trees, floras and things you want to evenly cover the area in.

`BrownianNoise(PerlinNoise)`, `BrownianNoise(SimplexNoise)`: use to create more complex, organic terrain by overlaying different layers of noise.

`BrownianNoise(Noise)`: use to overlay different layers of noise to get more complex results.

`SubSampledNoise`: use to smooth out the above noises by "zooming in" or "stretching" the values out.